{"version":3,"file":"index.js","mappings":"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","sources":["webpack://phaser-align/./demo/index.ts","webpack://phaser-align/./src/Align.ts","webpack://phaser-align/./src/index.ts"],"sourcesContent":["import * as Phaser from 'phaser';\nimport {Align} from '../src';\n\nconsole.log('Hello, Demo!');\n\nconst Assets = {\n    sprites: {\n        king: './assets/king.png'\n    }\n}\n\nexport class DemoScene extends Phaser.Scene {\n    preload() {\n        this.load.image(Assets.sprites.king, Assets.sprites.king);\n\n    }\n\n    create() {\n        console.log(\"DemoScene created...\");\n\n        const kingSprite = this.add.sprite(0, 0, Assets.sprites.king);\n        const align = new Align();\n        align\n            .anchorSceneScreen(this)\n            .center(kingSprite)\n\n    }\n}\n\nconst scaleConfig: Phaser.Types.Core.ScaleConfig = {\n    mode: Phaser.Scale.FIT,\n    autoCenter: Phaser.Scale.CENTER_BOTH,\n    parent: \"game\",\n    width: 960,\n    height: 640,\n};\n\nexport type IPhaserConfig = Phaser.Types.Core.GameConfig;\n\nexport const phaserConfig: IPhaserConfig = {\n    type: Phaser.AUTO,\n    backgroundColor: 0x222222,\n    transparent: true,\n    scale: scaleConfig,\n    scene: [new DemoScene(DemoScene.name)],\n};\n\nconst game = new Phaser.Game(phaserConfig);\n","import * as Phaser from 'phaser';\n\nexport type AlignObject =\n    | Phaser.GameObjects.Container\n    | Phaser.GameObjects.Image\n    | Phaser.GameObjects.Text\n    | Phaser.GameObjects.RenderTexture\n    | Phaser.GameObjects.Shape\n    | Phaser.GameObjects.TileSprite;\n\n// for origin == 0\n// all offsets move to right && down by default\n// chainable methods\nexport class Align {\n    private anchorItem: ISizeable | undefined;\n    private static errorSetAnchorMessage = 'set anchor in Align first';\n\n    constructor(anchorItem?: ISizeable) {\n        if (anchorItem) this.anchorItem = anchorItem;\n    }\n\n    /**\n     * объект относительно которого надо выравнивать\n     * @param item\n     */\n    anchor(item: ISizeable): this {\n        this.anchorItem = item;\n        return this;\n    }\n\n    /**\n     * Для выравнивания относительно экрана\n     * создается легкий делегат с нулевыми координатами\n     * @param width\n     * @param height\n     */\n    anchorScreen(width: number, height: number): this {\n        return this.anchor({\n            getBounds: () => new Phaser.Geom.Rectangle(0, 0, width, height),\n        });\n    }\n\n    anchorSceneScreen(scene: Phaser.Scene): this {\n        const { width, height } = scene.cameras.main;\n        return this.anchorScreen(width, height);\n    }\n\n    center(item: AlignObject, oX = 0, oY = 0): this {\n        return this.applyFormula(item, oX, oY, ({ aB, iB }) => ({\n            x: aB.x + (aB.width - iB.width) / 2,\n            y: aB.y + (aB.height - iB.height) / 2,\n        }));\n    }\n\n    centerX(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x + (aB.width - iB.width) / 2,\n            y: iB.y,\n        }));\n    }\n\n    centerY(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y + (aB.height - iB.height) / 2,\n        }));\n    }\n\n    bottomIn(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y + (aB.height - iB.height),\n        }));\n    }\n\n    bottomTo(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y + aB.height,\n        }));\n    }\n\n    topIn(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y,\n        }));\n    }\n\n    topTo(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y - iB.height,\n        }));\n    }\n\n    rightIn(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x + (aB.width - iB.width),\n            y: iB.y,\n        }));\n    }\n\n    rightTo(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x + aB.width,\n            y: iB.y,\n        }));\n    }\n\n    leftIn(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x,\n            y: iB.y,\n        }));\n    }\n\n    leftTo(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x - iB.width,\n            y: iB.y,\n        }));\n    }\n\n    /**\n     * @method setPosition - размещает объект с любым Origin\n     * для использования в цепочках с выравниванием по анкору\n     * @param item\n     * @param left\n     * @param top\n     */\n    setPosition(item: AlignObject, left: number, top: number): this {\n        Align.setLeftTop(item, left, top);\n        return this;\n    }\n\n    /**\n     * @method setLeftTop - размещает объект с любым Origin\n     * для использования без создания Align\n     * когда нужно просто разместить объект\n     * @param item\n     * @param left\n     * @param top\n     */\n    static setLeftTop(item: AlignObject, left: number, top: number) {\n        // bounds - реальное положение объекта вне зависимости  от origin\n        const iB = item.getBounds();\n        // находим разницу между  границами сейчас и что надо\n        const dX = left - iB.left;\n        const dY = top - iB.top;\n        // вычисляем перемещение по осям\n        const x = item.x + dX;\n        const y = item.y + dY;\n        // применяем перемещение\n        item.setPosition(x, y);\n    }\n\n    // выстроить объекты в ряд с расстоянием dX, друг за другом\n    row(items: AlignObject[], dX: number): this {\n        this.anchor(items[0]);\n        for (let i = 1; i < items.length; i++) {\n            const next = items[i];\n            this.rightTo(next, dX);\n            this.anchor(next);\n        }\n        return this;\n    }\n\n    // выстроить объекты в колонку с расстоянием dY, друг за другом\n    column(items: AlignObject[], dY: number): this {\n        this.anchor(items[0]);\n        for (let i = 1; i < items.length; i++) {\n            const next = items[i];\n            this.bottomTo(next, dY);\n            this.anchor(next);\n        }\n        return this;\n    }\n\n    private applyFormula(item: AlignObject, oX: number, oY: number, formula: IAlignFormula): this {\n        const { anchorItem } = this;\n        if (anchorItem == null) {\n            console.warn(Align.errorSetAnchorMessage);\n            return this;\n        }\n        if (item == null) {\n            console.warn(Align.errorSetAnchorMessage);\n            return this;\n        }\n\n        const { x, y } = formula(this.getBounds(item, anchorItem));\n        this.setPosition(item, x + oX, y + oY);\n\n        return this;\n    }\n\n    private getBounds(item: ISizeable, anchor: ISizeable): IBoundsPair {\n        return {\n            aB: anchor?.getBounds(),\n            iB: item?.getBounds(),\n        };\n    }\n}\n\ninterface ISizeable {\n    getBounds(): Phaser.Geom.Rectangle;\n}\n\ninterface IBoundsPair {\n    aB: Phaser.Geom.Rectangle;\n    iB: Phaser.Geom.Rectangle;\n}\n\ninterface IPosition {\n    x: number;\n    y: number;\n}\n\ninterface IAlignFormula {\n    (bounds: IBoundsPair): IPosition;\n}\n","export * from './Align';\n"],"names":[],"sourceRoot":""}