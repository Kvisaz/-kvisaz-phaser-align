{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@kvisaz/phaser-align/./demo/Assets.ts","webpack://@kvisaz/phaser-align/./demo/DemoScene.ts","webpack://@kvisaz/phaser-align/./demo/config.ts","webpack://@kvisaz/phaser-align/./demo/index.ts","webpack://@kvisaz/phaser-align/./demo/utils.ts","webpack://@kvisaz/phaser-align/./src/Align.ts","webpack://@kvisaz/phaser-align/./src/index.ts"],"sourcesContent":["export const Assets = {\n  sprites: {\n    king: \"./assets/king.png\",\n  },\n};\n","import Phaser from \"phaser\";\nimport { Align } from \"../src\";\nimport { Assets } from \"./Assets\";\nimport { cssColorToInt } from \"./utils\";\nimport {PhaserTextStyleConfig} from './types';\n\nexport class DemoScene extends Phaser.Scene {\n  preload() {\n    this.load.image(Assets.sprites.king, Assets.sprites.king);\n  }\n\n  create() {\n    console.log(\"DemoScene created...\");\n    this.cameras.main.setBackgroundColor(cssColorToInt(\"#ced5c0\"));\n\n    const kingSprite = this.add.sprite(0, 0, Assets.sprites.king);\n\n    const textStyle: PhaserTextStyleConfig = {\n      fontSize: '32px',\n      color: '#000000'\n    }\n\n    const text1 = this.add.text(0, 0, 'over Spite', textStyle);\n    const text2 = this.add.text(0, 0, 'under Spite', textStyle);\n    const text3 = this.add.text(0, 0, 'left from Spite', textStyle);\n    const text4 = this.add.text(0, 0, 'right from Spite', textStyle);\n\n    const distance = 24;\n    /** create align object to layout what you need **/\n    const align = new Align();\n    align.anchorSceneScreen(this).center(kingSprite);\n\n    align.anchor(kingSprite)\n        .center(text1).topTo(text1, -distance)\n        .center(text2).bottomTo(text2, distance)\n        .center(text3).leftTo(text3, -distance)\n        .center(text4).rightTo(text4, distance)\n\n\n    const rect1 = this.add.rectangle(0,0, 64, 64, cssColorToInt('#be8e1a'));\n    const rect2 = this.add.rectangle(0,0, 64, 64, cssColorToInt('#be8e1a'));\n    const rect3 = this.add.rectangle(0,0, 64, 64, cssColorToInt('#be8e1a'));\n    const rect4 = this.add.rectangle(0,0, 64, 64, cssColorToInt('#be8e1a'));\n\n    const rectDistance = 8;\n    align.anchor(text1).center(rect1).topTo(rect1, -rectDistance);\n    align.anchor(text2).center(rect2).bottomTo(rect2, rectDistance);\n    align.anchor(text3).center(rect3).leftTo(rect3, -rectDistance);\n    align.anchor(text4).center(rect4).rightTo(rect4, rectDistance);\n  }\n}\n","import Phaser from \"phaser\";\nimport { DemoScene } from \"./DemoScene\";\n\nconst scaleConfig: Phaser.Types.Core.ScaleConfig = {\n  mode: Phaser.Scale.FIT,\n  autoCenter: Phaser.Scale.CENTER_BOTH,\n  parent: \"game\",\n  width: 960,\n  height: 640,\n};\n\nexport type IPhaserConfig = Phaser.Types.Core.GameConfig;\n\nexport const phaserConfig: IPhaserConfig = {\n  type: Phaser.AUTO,\n  backgroundColor: \"#4488aa\",\n  transparent: true,\n  scale: scaleConfig,\n  scene: [new DemoScene(DemoScene.name)],\n};\n","import * as Phaser from \"phaser\";\nimport packageInfo from \"../package.json\";\nimport { phaserConfig } from \"./config\";\n\nconsole.log(`Hello, Demo ${packageInfo.version}!`);\nnew Phaser.Game(phaserConfig);\n","/**\n * convert cssColor string To Phaser Int color\n * @param cssColor like #dedede, #afafaf, etc\n * @return {number} like 0xdedede, 0xafafaf, etc\n */\nexport function cssColorToInt(cssColor: string): number {\n    try {\n        return parseInt(cssColor.replace(\"#\", \"0x\"));\n    } catch (e) {\n        console.warn(\"cssColorToInt: use cssColor with # prefix \");\n        return 0xdedede;\n    }\n}\n","import * as Phaser from 'phaser';\n\nexport type AlignObject =\n    | Phaser.GameObjects.Container\n    | Phaser.GameObjects.Image\n    | Phaser.GameObjects.Text\n    | Phaser.GameObjects.RenderTexture\n    | Phaser.GameObjects.Shape\n    | Phaser.GameObjects.TileSprite;\n\n// for origin == 0\n// all offsets move to right && down by default\n// chainable methods\nexport class Align {\n    private anchorItem: ISizeable | undefined;\n    private static errorSetAnchorMessage = 'set anchor in Align first';\n\n    constructor(anchorItem?: ISizeable) {\n        if (anchorItem) this.anchorItem = anchorItem;\n    }\n\n    /**\n     * объект относительно которого надо выравнивать\n     * @param item\n     */\n    anchor(item: ISizeable): this {\n        this.anchorItem = item;\n        return this;\n    }\n\n    /**\n     * Для выравнивания относительно экрана\n     * создается легкий делегат с нулевыми координатами\n     * @param width\n     * @param height\n     */\n    anchorScreen(width: number, height: number): this {\n        return this.anchor({\n            getBounds: () => new Phaser.Geom.Rectangle(0, 0, width, height),\n        });\n    }\n\n    anchorSceneScreen(scene: Phaser.Scene): this {\n        const { width, height } = scene.cameras.main;\n        return this.anchorScreen(width, height);\n    }\n\n    center(item: AlignObject, oX = 0, oY = 0): this {\n        return this.applyFormula(item, oX, oY, ({ aB, iB }) => ({\n            x: aB.x + (aB.width - iB.width) / 2,\n            y: aB.y + (aB.height - iB.height) / 2,\n        }));\n    }\n\n    centerX(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x + (aB.width - iB.width) / 2,\n            y: iB.y,\n        }));\n    }\n\n    centerY(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y + (aB.height - iB.height) / 2,\n        }));\n    }\n\n    bottomIn(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y + (aB.height - iB.height),\n        }));\n    }\n\n    bottomTo(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y + aB.height,\n        }));\n    }\n\n    topIn(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y,\n        }));\n    }\n\n    topTo(item: AlignObject, oY = 0): this {\n        return this.applyFormula(item, 0, oY, ({ aB, iB }) => ({\n            x: iB.x,\n            y: aB.y - iB.height,\n        }));\n    }\n\n    rightIn(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x + (aB.width - iB.width),\n            y: iB.y,\n        }));\n    }\n\n    rightTo(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x + aB.width,\n            y: iB.y,\n        }));\n    }\n\n    leftIn(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x,\n            y: iB.y,\n        }));\n    }\n\n    leftTo(item: AlignObject, oX = 0): this {\n        return this.applyFormula(item, oX, 0, ({ aB, iB }) => ({\n            x: aB.x - iB.width,\n            y: iB.y,\n        }));\n    }\n\n    /**\n     * @method setPosition - размещает объект с любым Origin\n     * для использования в цепочках с выравниванием по анкору\n     * @param item\n     * @param left\n     * @param top\n     */\n    setPosition(item: AlignObject, left: number, top: number): this {\n        Align.setLeftTop(item, left, top);\n        return this;\n    }\n\n    /**\n     * @method setLeftTop - размещает объект с любым Origin\n     * для использования без создания Align\n     * когда нужно просто разместить объект\n     * @param item\n     * @param left\n     * @param top\n     */\n    static setLeftTop(item: AlignObject, left: number, top: number) {\n        // bounds - реальное положение объекта вне зависимости  от origin\n        const iB = item.getBounds();\n        // находим разницу между  границами сейчас и что надо\n        const dX = left - iB.left;\n        const dY = top - iB.top;\n        // вычисляем перемещение по осям\n        const x = item.x + dX;\n        const y = item.y + dY;\n        // применяем перемещение\n        item.setPosition(x, y);\n    }\n\n    // выстроить объекты в ряд с расстоянием dX, друг за другом\n    row(items: AlignObject[], dX: number): this {\n        this.anchor(items[0]);\n        for (let i = 1; i < items.length; i++) {\n            const next = items[i];\n            this.rightTo(next, dX);\n            this.anchor(next);\n        }\n        return this;\n    }\n\n    // выстроить объекты в колонку с расстоянием dY, друг за другом\n    column(items: AlignObject[], dY: number): this {\n        this.anchor(items[0]);\n        for (let i = 1; i < items.length; i++) {\n            const next = items[i];\n            this.bottomTo(next, dY);\n            this.anchor(next);\n        }\n        return this;\n    }\n\n    private applyFormula(item: AlignObject, oX: number, oY: number, formula: IAlignFormula): this {\n        const { anchorItem } = this;\n        if (anchorItem == null) {\n            console.warn(Align.errorSetAnchorMessage);\n            return this;\n        }\n        if (item == null) {\n            console.warn(Align.errorSetAnchorMessage);\n            return this;\n        }\n\n        const { x, y } = formula(this.getBounds(item, anchorItem));\n        this.setPosition(item, x + oX, y + oY);\n\n        return this;\n    }\n\n    private getBounds(item: ISizeable, anchor: ISizeable): IBoundsPair {\n        return {\n            aB: anchor.getBounds(),\n            iB: item.getBounds(),\n        };\n    }\n}\n\ninterface ISizeable {\n    getBounds(): Phaser.Geom.Rectangle;\n}\n\ninterface IBoundsPair {\n    aB: Phaser.Geom.Rectangle;\n    iB: Phaser.Geom.Rectangle;\n}\n\ninterface IPosition {\n    x: number;\n    y: number;\n}\n\ninterface IAlignFormula {\n    (bounds: IBoundsPair): IPosition;\n}\n","export * from './Align';\n"],"names":[],"sourceRoot":""}